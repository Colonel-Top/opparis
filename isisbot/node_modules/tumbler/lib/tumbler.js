(function() {
  var Builder, BundleCompiler, Compiler, DebugBundleCompiler, MODES, ReleaseBundleCompiler, SimpleCompiler, TrivialCompiler, W_FILE, all, concatenate, extract_extension, fs, head, headtail, is_fresher, makeBuilder, makeBuilderConcat, makeBuilderDebug, makeBuilderRelease, path, spawn, tail, writeScriptTags;
  var __hasProp = Object.prototype.hasOwnProperty, __extends = function(child, parent) {
    for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; }
    function ctor() { this.constructor = child; }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor;
    child.__super__ = parent.prototype;
    return child;
  }, __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };
  fs = require('fs');
  path = require('path');
  spawn = require('child_process').spawn;
  W_FILE = {
    flags: 'w',
    encoding: 'utf-8'
  };
  head = function(l) {
    return l[0];
  };
  tail = function(l) {
    return l.slice(1);
  };
  headtail = function(l) {
    return [head(l), tail(l)];
  };
  extract_extension = function(filepath) {
    var ext_match;
    ext_match = filepath.match(/(.*)\.([^\.]+)/);
    if (ext_match) {
      return {
        base: ext_match[1],
        ext: ext_match[2],
        filepath: filepath
      };
    } else {
      return {
        base: filepath,
        ext: null,
        filepath: filepath
      };
    }
  };
  is_fresher = function(src, dest) {
    /*
        src and dest must be existing
        filepaths.
        Returns true if src has been modified 
        more recently than dest.
        */
    var dest_stat, src_stat;
    src_stat = fs.statSync(src);
    dest_stat = fs.statSync(dest);
    return src_stat.mtime > dest_stat.mtime;
  };
  Compiler = (function() {
    function Compiler() {}
    Compiler.prototype.match = function(dest) {};
    Compiler.prototype.get_source_list = function(dest) {};
    Compiler.prototype.build = function(dest, success, failure) {};
    return Compiler;
  })();
  all = function(predicate, els) {
    var el, _i, _len;
    for (_i = 0, _len = els.length; _i < _len; _i++) {
      el = els[_i];
      if (!(predicate(el))) {
        return false;
      }
    }
    return true;
  };
  SimpleCompiler = (function() {
    __extends(SimpleCompiler, Compiler);
    /*
        Compiler with 1-1 relationship between
        source files and dest files 
        and an explicit extension for both.
        */
    function SimpleCompiler(extSrc, extDest, command, command_args) {
      this.extSrc = extSrc;
      this.extDest = extDest;
      this.command = command;
      this.command_args = command_args != null ? command_args : [];
    }
    SimpleCompiler.prototype.match = function(dest) {
      var split;
      split = extract_extension(dest);
      return (split.ext === this.extDest) && (path.existsSync(this.get_source(dest)));
    };
    SimpleCompiler.prototype.get_source = function(dest) {
      var split;
      split = extract_extension(dest);
      return split.base + "." + this.extSrc;
    };
    SimpleCompiler.prototype.get_source_list = function(dest) {
      return [this.get_source(dest)];
    };
    SimpleCompiler.prototype.make_command = function(src) {
      var args;
      args = this.command_args.slice();
      args.push(src);
      return [this.command, args];
    };
    SimpleCompiler.prototype.build = function(dest, success, failure) {
      var child, cmd, dest_file, error_msg, src;
      src = this.get_source(dest);
      console.log("compiling " + src + " -> " + dest);
      cmd = this.make_command(src);
      dest_file = fs.createWriteStream(dest, W_FILE);
      child = spawn.apply(this, cmd);
      child.stdout.pipe(dest_file);
      error_msg = "";
      child.stderr.on("data", function(data) {
        return error_msg += data.toString();
      });
      return child.on("exit", function(code) {
        if (code === 0) {
          return success();
        } else {
          console.log("compilation failed");
          fs.unlink(dest);
          return failure(error_msg);
        }
      });
    };
    return SimpleCompiler;
  })();
  concatenate = function(sources, dest_file, success, failure) {
    var f, h, t, _ref;
    if (sources.length === 0) {
      return success();
    } else {
      try {
        _ref = headtail(sources), h = _ref[0], t = _ref[1];
        f = fs.createReadStream(h);
        f.on("end", function() {
          return concatenate(t, dest_file, success, failure);
        });
        return f.pipe(dest_file);
      } catch (err) {
        return failure("Bundle failure!");
      }
    }
  };
  BundleCompiler = (function() {
    __extends(BundleCompiler, Compiler);
    function BundleCompiler() {
      BundleCompiler.__super__.constructor.apply(this, arguments);
    }
    /*
        Compiler with 1-1 relationship between
        source files and dest files 
        and an explicit extension for both.
        */
    BundleCompiler.prototype.match = function(dest) {
      var source;
      source = this.get_bundle_detail_file(dest);
      return path.existsSync(source);
    };
    BundleCompiler.prototype.get_bundle_detail_file = function(dest) {
      return dest + ".bundle";
    };
    BundleCompiler.prototype.get_source_list = function(dest) {
      return [this.get_bundle_detail_file(dest)].concat(this.get_target_list(dest));
    };
    BundleCompiler.prototype.get_target_list = function(dest) {
      var bundle_detail_data, bundle_detail_file, l, relpath, root, sources, splitPtn, _i, _len, _ref;
      root = path.dirname(dest);
      bundle_detail_file = this.get_bundle_detail_file(dest);
      bundle_detail_data = (fs.readFileSync(bundle_detail_file, 'utf-8')).toString();
      splitPtn = new RegExp("\\s+");
      sources = [];
      _ref = bundle_detail_data.split(splitPtn);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        l = _ref[_i];
        relpath = l.trim();
        if (relpath.length > 0) {
          sources.push(path.join(root, relpath));
        }
      }
      return sources;
    };
    BundleCompiler.prototype.build = function(dest, success, failure) {
      var dest_file, targets;
      targets = this.get_target_list(dest);
      dest_file = fs.createWriteStream(dest, W_FILE);
      return concatenate(targets, dest_file, success, failure);
    };
    return BundleCompiler;
  })();
  writeScriptTags = function(sources, dest_file, urlPrefix, success, failure) {
    var scriptTags, source, _i, _len;
    scriptTags = "";
    for (_i = 0, _len = sources.length; _i < _len; _i++) {
      source = sources[_i];
      scriptTags += "\\t<script src='" + (urlPrefix + source) + "' text='javascript'></script>\\n";
    }
    fs.writeSync(dest_file, 'document.write("' + scriptTags + '");\n');
    fs.closeSync(dest_file);
    return success();
  };
  ReleaseBundleCompiler = (function() {
    __extends(ReleaseBundleCompiler, BundleCompiler);
    function ReleaseBundleCompiler() {
      this.uglify = require('uglify-js');
    }
    ReleaseBundleCompiler.prototype.build = function(dest, success, failure) {
      var child, dest_file, error_msg, targets;
      targets = this.get_target_list(dest);
      dest_file = fs.openSync(dest, 'w', W_FILE);
      dest_file = fs.createWriteStream(dest, W_FILE);
      child = spawn('uglifyjs', ["-b", "--reserved-names", "arguments"]);
      concatenate(targets, child.stdin, (function(m) {
        return console.log("concat success");
      }), (function(m) {
        return console.log("error");
      }));
      child.stdout.pipe(dest_file);
      error_msg = "";
      child.stderr.on("data", function(data) {
        console.log("ERR:", data.toString());
        return error_msg += data.toString();
      });
      return child.on("exit", function(code) {
        if (code === 0) {
          return success();
        } else {
          console.log("compilation failed");
          fs.unlink(dest);
          return failure(error_msg);
        }
      });
    };
    return ReleaseBundleCompiler;
  })();
  DebugBundleCompiler = (function() {
    __extends(DebugBundleCompiler, BundleCompiler);
    function DebugBundleCompiler(config) {
      this.urlPrefix = config.urlPrefix;
    }
    DebugBundleCompiler.prototype.get_source_list = function(dest) {
      return [this.get_bundle_detail_file(dest)];
    };
    DebugBundleCompiler.prototype.build = function(dest, success, failure) {
      var dest_file, targets;
      targets = this.get_target_list(dest);
      dest_file = fs.openSync(dest, 'w', W_FILE);
      return writeScriptTags(targets, dest_file, this.urlPrefix, success, failure);
    };
    return DebugBundleCompiler;
  })();
  TrivialCompiler = (function() {
    __extends(TrivialCompiler, Compiler);
    function TrivialCompiler() {
      TrivialCompiler.__super__.constructor.apply(this, arguments);
    }
    TrivialCompiler.prototype.match = function(dest) {
      return true;
    };
    TrivialCompiler.prototype.get_source_list = function(dest) {
      return [];
    };
    TrivialCompiler.prototype.build = function(dest, success, failure) {
      if (path.existsSync(dest)) {
        return success();
      } else {
        return failure("File not found.");
      }
    };
    return TrivialCompiler;
  })();
  Builder = (function() {
    function Builder(alwaysCompile) {
      this.alwaysCompile = alwaysCompile;
      this.history = {};
      this.compilers = [];
    }
    Builder.prototype.register_compiler = function(compiler) {
      return this.compilers.push(compiler);
    };
    Builder.prototype.buildAll = function(dests, success, failure) {
      var dest, remaining, _ref;
      if (dests.length === 0) {
        return success();
      } else {
        _ref = headtail(dests), dest = _ref[0], remaining = _ref[1];
        return this.build(dest, (__bind(function() {
          return this.buildAll(remaining, success, failure);
        }, this)), failure);
      }
    };
    Builder.prototype._build_with_compiler = function(compiler, dest, success, failure) {
      var sources, sources_are_ready;
      sources = compiler.get_source_list(dest);
      sources_are_ready = __bind(function() {
        var older_than_dest;
        older_than_dest = __bind(function(src) {
          return is_fresher(dest, src);
        }, this);
        if (this.alwaysCompile || (!(this.history[dest] != null)) || (!path.existsSync(dest)) || !all(older_than_dest, sources)) {
          this.history[dest] = true;
          return compiler.build(dest, success, failure);
        } else {
          return success();
        }
      }, this);
      return this.buildAll(sources.slice(), sources_are_ready, failure);
    };
    Builder.prototype.build = function(dest, success, failure) {
      /*
              build destination when required
              */
      var compiler, _i, _len, _ref;
      _ref = this.compilers;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        compiler = _ref[_i];
        if (compiler.match(dest)) {
          this._build_with_compiler(compiler, dest, success, failure);
          return;
        }
      }
      return failure({
        msg: "couldn't find any compiler"
      });
    };
    return Builder;
  })();
  makeBuilderConcat = function(config) {
    var builder, sprite;
    builder = new Builder(config.alwaysCompile === true);
    builder.register_compiler(new BundleCompiler);
    builder.register_compiler(new SimpleCompiler('coffee', 'js', 'coffee', ['-p']));
    try {
      sprite = require('tumbler-sprite');
      builder.register_compiler(new sprite.SpriteCompiler());
    } catch (exception) {
      console.log("Couldn't load sprite");
    }
    builder.register_compiler(new SimpleCompiler('less', 'css', 'lessc', []));
    builder.register_compiler(new TrivialCompiler());
    return builder;
  };
  makeBuilderRelease = function(config) {
    var builder, sprite;
    builder = new Builder(config.alwaysCompile === true);
    builder.register_compiler(new ReleaseBundleCompiler);
    builder.register_compiler(new SimpleCompiler('coffee', 'js', 'coffee', ['-p']));
    try {
      sprite = require('tumbler-sprite');
      builder.register_compiler(new sprite.SpriteCompiler());
    } catch (exception) {
      console.log("Couldn't load sprite");
    }
    builder.register_compiler(new SimpleCompiler('less', 'css', 'lessc', []));
    builder.register_compiler(new TrivialCompiler());
    return builder;
  };
  makeBuilderDebug = function(config) {
    var builder, sprite;
    builder = new Builder(config.alwaysCompile === true);
    builder.register_compiler(new DebugBundleCompiler({
      urlPrefix: "http://" + config.host + ":" + config.port + "/"
    }));
    builder.register_compiler(new SimpleCompiler('coffee', 'js', 'coffee', ['-p']));
    try {
      sprite = require('tumbler-sprite');
      builder.register_compiler(new sprite.SpriteCompiler());
    } catch (exception) {
      console.log("Couldn't load sprite");
    }
    builder.register_compiler(new SimpleCompiler('less', 'css', 'lessc', []));
    builder.register_compiler(new TrivialCompiler());
    return builder;
  };
  MODES = {
    "release": makeBuilderRelease,
    "concat": makeBuilderConcat,
    "debug": makeBuilderDebug
  };
  makeBuilder = function(config) {
    return MODES[config.mode](config);
  };
  exports.makeBuilder = makeBuilder;
  exports.Compiler = Compiler;
  exports.BundleCompiler = BundleCompiler;
  exports.SimpleCompiler = SimpleCompiler;
  exports.TrivialCompiler = TrivialCompiler;
  exports.Builder = Builder;
}).call(this);
