(function() {
  var ArgumentParser, chainMap, copyFile, fs, mergeDic, mergeTwoDic, mkdirsSync, parentDirs, path, prompt, readJsonSync, readLinesSync, reduce, test, yesno_prompt;
  var __slice = Array.prototype.slice;
  fs = require('fs');
  path = require('path');
  mergeTwoDic = function(d, d2) {
    var k, v;
    for (k in d2) {
      v = d2[k];
      d[k] = v;
    }
    return d;
  };
  reduce = function(op, l) {
    var el, res, _i, _len, _ref;
    if (l.length === 0) {
      throw "Cannot apply reduce on empty list.";
    } else {
      res = l[0];
      _ref = l.slice(1);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        el = _ref[_i];
        res = op(res, el);
      }
      return res;
    }
  };
  exports.reduce = reduce;
  mergeDic = function() {
    var args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return reduce(mergeTwoDic, args);
  };
  exports.mergeDic = mergeDic;
  readJsonSync = function(filepath) {
    var json;
    if (path.existsSync(filepath)) {
      json = fs.readFileSync(filepath, "utf-8");
      return JSON.parse(data);
    } else {
      return;
    }
  };
  parentDirs = function(dirpath) {
    var cur, parent, res, _results;
    res = [dirpath];
    cur = dirpath;
    _results = [];
    while (true) {
      parent = path.dirname(cur);
      if (parent === cur) {
        return res;
      } else {
        res.push(cur);
        cur = parent;
      }
    }
    return _results;
  };
  mkdirsSync = function(dirpath) {
    var parent, parents, realdirpath, _i, _len, _results;
    realdirpath = path.resolve(process.cwd(), dirpath);
    parents = parentDirs(realdirpath);
    parents.reverse();
    _results = [];
    for (_i = 0, _len = parents.length; _i < _len; _i++) {
      parent = parents[_i];
      _results.push(!path.existsSync(parent) ? fs.mkdirSync(parent, 0777) : void 0);
    }
    return _results;
  };
  exports.mkdirsSync = mkdirsSync;
  readLinesSync = function(filepath) {
    var content;
    if (path.existsSync(filepath)) {
      content = fs.readFileSync(filepath, "utf-8");
      return content.trim().split("\n");
    } else {
      return;
    }
  };
  exports.readLinesSync = readLinesSync;
  exports.readJsonSync = readJsonSync;
  exports.writeJsonSync = function(filepath, data) {
    var json;
    json = JSON.stringify(data);
    return fs.writeFileSync(file, json, "utf-8");
  };
  prompt = function(question, callback) {
    console.log(question);
    process.stdin.resume();
    return process.stdin.once("data", function(data) {
      process.stdin.pause();
      return callback(data.toString().trim());
    });
  };
  yesno_prompt = function(question, callback) {
    var ANSWER, handle_answer;
    ANSWER = {
      "y": true,
      "yes": true,
      "n": false,
      "no": false
    };
    handle_answer = function(answer) {
      answer = answer.toLowerCase();
      if (ANSWER[answer] != null) {
        return callback(ANSWER[answer]);
      } else {
        console.log("You need to answer by either yes or no.");
        return yesno_prompt(question, callback);
      }
    };
    return prompt(question + " [y/n]", handle_answer);
  };
  exports.yesno_prompt = yesno_prompt;
  exports.prompt = prompt;
  ArgumentParser = (function() {
    function ArgumentParser(config) {
      var config_key, help, need_arg, option, options, _i, _j, _len, _len2, _ref, _ref2;
      this.argumentOptions = config.args;
      this.defaultConfig = config.defaultConfig;
      this.jsonConfigFile = config.configFile;
      this.parseOptionMap = {};
      _ref = this.argumentOptions;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        _ref2 = _ref[_i], options = _ref2[0], config_key = _ref2[1], need_arg = _ref2[2], help = _ref2[3];
        for (_j = 0, _len2 = options.length; _j < _len2; _j++) {
          option = options[_j];
          this.parseOptionMap[option] = [config_key, need_arg];
        }
      }
    }
    ArgumentParser.prototype.setHelpMessage = function(helpMessage) {
      this.helpMessage = helpMessage;
    };
    ArgumentParser.prototype.help = function() {
      var config_key, help, need_arg, options, _i, _len, _ref, _ref2;
      if (this.helpMessage != null) {
        console.log(this.helpMessage);
      }
      console.log("\nusage:");
      console.log(' ' + __filename + " [options]\n");
      console.log('options :');
      _ref = this.argumentOptions;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        _ref2 = _ref[_i], options = _ref2[0], config_key = _ref2[1], need_arg = _ref2[2], help = _ref2[3];
        if (need_arg) {
          console.log('   ' + options + ' option : ' + help);
        } else {
          console.log('   ' + options + ' : ' + help);
        }
      }
      return console.log('');
    };
    ArgumentParser.prototype._getFileConfig = function() {
      var fileConfig;
      if (this.jsonConfigFile != null) {
        fileConfig = readJsonSync(this.jsonConfigFile);
        if (fileConfig != null) {
          return fileConfig;
        }
      }
      return {};
    };
    ArgumentParser.prototype.print = function(config) {
      var k, v, _results;
      _results = [];
      for (k in config) {
        v = config[k];
        _results.push(console.log("-", k, ": ", v));
      }
      return _results;
    };
    ArgumentParser.prototype.parse = function(argv) {
      var commandLineConfig, config_key, need_arg, option, parseOption;
      commandLineConfig = {};
      while (argv.length > 0) {
        option = argv.shift();
        parseOption = this.parseOptionMap[option];
        if (parseOption != null) {
          config_key = parseOption[0], need_arg = parseOption[1];
          if (need_arg) {
            commandLineConfig[config_key] = argv.shift();
          } else {
            commandLineConfig[config_key] = true;
          }
        } else {
          throw "Option unknown : " + option;
        }
      }
      return mergeDic(this._getFileConfig(), this.defaultConfig, commandLineConfig);
    };
    return ArgumentParser;
  })();
  exports.ArgumentParser = ArgumentParser;
  chainMap = function(f, v, success, failure) {
    var h, stepSuccess, t;
    if (v.length === 0) {
      return success();
    } else {
      h = v[0];
      t = v.slice(1);
      stepSuccess = function() {
        return chainMap(f, t, success, failure);
      };
      return f.apply(null, __slice.call(h).concat([stepSuccess], [failure]));
    }
  };
  exports.chainMap = chainMap;
  copyFile = function(srcPath, destPath, success, failure) {
    var destStream, srcStream;
    try {
      srcStream = fs.createReadStream(srcPath);
      destStream = fs.createWriteStream(destPath);
      srcStream.on("end", function() {
        success();
        return destStream.destroySoon();
      });
      return srcStream.pipe(destStream);
    } catch (e) {
      console.log("failure");
      return failure(e);
    }
  };
  module.exports.copyFile = copyFile;
  test = function() {
    var failure, success;
    success = function() {
      return console.log("success");
    };
    failure = function(e) {
      return console.log("failure:", e);
    };
    return copyFile("./titi", "./toto", success, failure);
  };
  if (require.main === module) {
    test();
  }
}).call(this);
