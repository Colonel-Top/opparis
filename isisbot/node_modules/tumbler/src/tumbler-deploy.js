(function() {
  var ARGUMENTS, ARGUMENTS_PARSER, ARGUMENTS_VALIDATION, assert, copyTargets, deploy, erase, fs, help, http, main, mime, path, prepare_directory, spawn, tumbler, utils, visit_directory;
  http = require('http');
  fs = require('fs');
  path = require('path');
  spawn = require('child_process').spawn;
  mime = require('mime');
  utils = require('../lib/utils.js');
  tumbler = require('tumbler');
  assert = require('assert');
  ARGUMENTS_VALIDATION = function(config) {
    if (!(config.destination != null)) {
      throw "Destination required.";
    }
  };
  ARGUMENTS = [[["-t", "--targets"], "targets", true, "Path to a JSON file containing the list of file to be deployed. Path should be relative to cwd."], [["-d", "--destination"], "destination", true, "Destination directory"], [["-h", "--help"], "help", false, "Print this help"], [["-m", "--mode"], "mode", true, "(debug|release)"]];
  ARGUMENTS_PARSER = new utils.ArgumentParser({
    args: ARGUMENTS,
    defaultConfig: {
      source: process.cwd(),
      mode: "release",
      targets: "targets"
    },
    configFile: ".tumbler"
  });
  help = function() {
    return ARGUMENTS_PARSER.help();
  };
  visit_directory = function(dir_path, action, cond) {
    var child, child_fullpath, child_stat, children, _i, _len, _results;
    if ((cond != null) && cond(dir_path)) {
      console.log("ok", dir_path);
      children = fs.readdirSync(dir_path);
      _results = [];
      for (_i = 0, _len = children.length; _i < _len; _i++) {
        child = children[_i];
        _results.push((function() {
          if (!(/\..*/.test(child))) {
            child_fullpath = path.join(dir_path, child);
            child_stat = fs.statSync(child_fullpath);
            if (child_stat.isDirectory()) {
              visit_directory(child_fullpath, action);
            }
            try {
              return action(child_fullpath);
            } catch (msg) {
              throw "Failed on " + child_fullpath;
            }
          }
        })());
      }
      return _results;
    } else {
      return console.log("fail", dir_path);
    }
  };
  erase = function(filepath) {
    var file_stat;
    file_stat = fs.statSync(filepath);
    if (file_stat.isDirectory()) {
      return fs.rmdirSync(filepath);
    } else {
      return fs.unlinkSync(filepath);
    }
  };
  prepare_directory = function(directory_path, callback) {
    var content;
    if (path.existsSync(directory_path)) {
      content = fs.readdirSync(directory_path);
      if (content.length === 0) {
        return callback(directory_path);
      } else {
        console.log("Directory not empty");
        console.log(directory_path);
        return utils.yesno_prompt("Do you want to erase all of its content", function(answer) {
          if (answer) {
            console.log("cleaning up");
            return visit_directory(directory_path, erase);
          } else {
            throw "Aborting...";
          }
        });
      }
    } else {
      try {
        fs.mkdirSync(directory_path, 0777);
      } catch (e) {
        throw "Could not make directory : " + directory_path;
      }
      return callback(directory_path);
    }
  };
  copyTargets = function(targets, destination) {
    var args, destPath, failure, parentDir, success, target, _i, _len;
    args = [];
    for (_i = 0, _len = targets.length; _i < _len; _i++) {
      target = targets[_i];
      destPath = path.join(destination, target);
      parentDir = path.dirname(destPath);
      utils.mkdirsSync(parentDir);
      args.push([target, destPath]);
    }
    success = function() {
      return console.log("Success");
    };
    failure = function(msg) {
      return console.log("Failure ", msg);
    };
    return utils.chainMap(utils.copyFile, args, success, failure);
  };
  deploy = function(builder, targets, destination) {
    var failure, success;
    console.log("Building");
    success = function() {
      return copyTargets(targets, destination);
    };
    failure = function() {
      return console.log("Compilation failed!");
    };
    return builder.buildAll(targets.slice(), success, failure);
  };
  main = function(argv) {
    var builder, config, destination, targets;
    try {
      config = ARGUMENTS_PARSER.parse(argv);
      builder = tumbler.makeBuilder(config);
      ARGUMENTS_PARSER.print(config);
      ARGUMENTS_VALIDATION(config);
      targets = utils.readLinesSync(config.targets);
      assert.ok(targets != null, "You need to define some targets.");
      destination = config.destination;
      return prepare_directory(destination, function() {
        return deploy(builder, targets, destination);
      });
    } catch (e) {
      console.log(e);
      console.log("-----------------");
      console.log(e.stack);
      return help();
    }
  };
  exports.main = main;
  exports.help = help;
  exports.DESCRIPTION = "Compiles and copies a given list of file to a dest directory.";
  if (require.main === module) {
    main(process.argv.slice(2));
  }
}).call(this);
