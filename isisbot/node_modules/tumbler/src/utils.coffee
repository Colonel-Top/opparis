fs = require 'fs'
path = require 'path'

mergeTwoDic = (d,d2)->
    for k,v of d2
        d[k] = v
    d

reduce = (op, l)->
    if l.length == 0
        throw "Cannot apply reduce on empty list."
    else
        res = l[0]
        for el in l[1..]
            res = op res,el
        res

exports.reduce = reduce

mergeDic = (args...)->
    reduce mergeTwoDic, args

exports.mergeDic = mergeDic

readJsonSync = (filepath)->
    #
    # Read json from a file in a synchronized way.
    #
    if path.existsSync filepath
        json =  fs.readFileSync filepath,"utf-8"
        JSON.parse data
    else
        undefined


parentDirs = (dirpath)->
    res = [dirpath]
    cur = dirpath
    while true
        parent = path.dirname cur
        if parent == cur
            return res
        else
            res.push cur
            cur = parent 

mkdirsSync = (dirpath)->
    # find existing root
    realdirpath = path.resolve process.cwd(), dirpath
    parents = parentDirs realdirpath
    parents.reverse()
    for parent in parents
        if not path.existsSync parent
            fs.mkdirSync parent, 0777

exports.mkdirsSync = mkdirsSync

readLinesSync = (filepath)->
    #
    # Return a list with the line within filepath.
    #
    if path.existsSync filepath
        content =  fs.readFileSync filepath,"utf-8"
        content.trim().split "\n"
    else
        undefined

exports.readLinesSync = readLinesSync

exports.readJsonSync = 
readJsonSync

exports.writeJsonSync = (filepath,data)->
    #
    # Write json to a file in a synchronized way.
    # data should be a json-like object.
    #
    json = JSON.stringify data 
    fs.writeFileSync file, json, "utf-8"

prompt=(question,callback)->
    #
    # Print out the question in the console, and
    # call the callback with the user input as argument.
    #
    console.log question
    process.stdin.resume()
    process.stdin.once "data",(data)->
        process.stdin.pause()
        callback data.toString().trim()

yesno_prompt=(question,callback)->
    #
    # Print out the question, and loops
    # until the user give yes or no as
    # an answer.
    #
    # The callback is then called with the
    # matching boolean value.
    #
    ANSWER = 
        "y": true
        "yes": true
        "n": false
        "no": false

    handle_answer=(answer)->
        answer = answer.toLowerCase() 
        if ANSWER[answer]?
            callback ANSWER[answer]
        else
            console.log "You need to answer by either yes or no."
            yesno_prompt question,callback
    prompt question + " [y/n]",handle_answer

exports.yesno_prompt = yesno_prompt
exports.prompt = prompt

class ArgumentParser
    #
    # In the following order.
    #   1) load default config,
    #   2) if jsonConfigFile is set, override with the 
    #   data contained in this file.
    #   3) if command line are given, override with
    #   command-line data.
    #
    constructor: (config)->
        @argumentOptions=config.args
        @defaultConfig=config.defaultConfig
        @jsonConfigFile=config.configFile
        @parseOptionMap = {}
        for [options, config_key, need_arg, help] in @argumentOptions
            for option in options
                @parseOptionMap[option] = [config_key, need_arg]

    setHelpMessage: (@helpMessage)->
    
    help: ->
        if @helpMessage?
            console.log @helpMessage
        console.log "\nusage:"
        console.log ' ' + __filename + " [options]\n"
        console.log 'options :'
        for [options, config_key, need_arg, help] in @argumentOptions
            if need_arg
                console.log '   ' + options + ' option : ' + help
            else
                console.log '   ' + options + ' : ' + help
        console.log ''
    
    _getFileConfig: ->
        if @jsonConfigFile?
            fileConfig = readJsonSync @jsonConfigFile
            if fileConfig?
                return fileConfig
        {}
    
    print: (config)->
        for k,v of config
            console.log "-", k, ": ", v 
    
    parse: (argv)->
        commandLineConfig = {}
        while (argv.length > 0)
            option = argv.shift()
            parseOption = @parseOptionMap[option]
            if parseOption?
                [config_key, need_arg] = parseOption
                if need_arg
                    commandLineConfig[config_key] = argv.shift()
                else
                    commandLineConfig[config_key] = true
            else
                throw "Option unknown : " + option
        mergeDic @_getFileConfig(),@defaultConfig,commandLineConfig

exports.ArgumentParser = ArgumentParser

chainMap = (f, v, success, failure)->
    if v.length == 0
        success()
    else
        h = v[0]
        t = v[1..]
        stepSuccess = ->
            chainMap f, t, success, failure
        f(h..., stepSuccess, failure)


exports.chainMap = chainMap

copyFile = (srcPath, destPath, success, failure)->
    try
        srcStream = fs.createReadStream srcPath
        destStream = fs.createWriteStream destPath
        srcStream.on "end", ->
            success()
            destStream.destroySoon()
        srcStream.pipe destStream
    catch e
        console.log "failure"
        failure e

module.exports.copyFile = copyFile


test = ->
    success = ->
        console.log "success"
    failure = (e)->
        console.log "failure:",e
    copyFile "./titi", "./toto", success, failure

if require.main == module
    test()