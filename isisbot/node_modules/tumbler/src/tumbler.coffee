#!/usr/bin/env coffee

fs = require 'fs' 
path = require 'path'
spawn = require('child_process').spawn

W_FILE =
    flags: 'w'
    encoding: 'utf-8'

head = (l)-> l[0]
tail = (l)-> l[1..]
headtail = (l)-> [ head(l) , tail(l) ]

extract_extension = (filepath)->
    ext_match = filepath.match /(.*)\.([^\.]+)/
    if ext_match 
        base: ext_match[1]
        ext: ext_match[2]
        filepath: filepath
    else
        base: filepath
        ext: null
        filepath: filepath

is_fresher = (src, dest)->
    ###
    src and dest must be existing
    filepaths.
    Returns true if src has been modified 
    more recently than dest.
    ###
    src_stat = fs.statSync src
    dest_stat = fs.statSync dest 
    src_stat.mtime > dest_stat.mtime

class Compiler 

    match: (dest)->
        # Returns true if the destination
        # can actually be built by this compiler.
    
    get_source_list: (dest)->
        # returns the list of 
        # sources that are required to build
        # the destination
    
    build: (dest, success, failure)->
        # here we may assume all sources
        # have already been built.


all = (predicate, els)->
    for el in els
        if not (predicate el)
            return false
    true


class SimpleCompiler extends Compiler
    ###
    Compiler with 1-1 relationship between
    source files and dest files 
    and an explicit extension for both.
    ###
    constructor: (@extSrc,@extDest,@command,@command_args=[])->
    
    match: (dest)->
        # Returns true if the destination
        # can actually be built by this compiler.
        split = extract_extension dest
        (split.ext==@extDest) and (path.existsSync @get_source dest)
    
    get_source: (dest)->
        split = extract_extension dest
        split.base + "." + @extSrc
    
    get_source_list: (dest)->
        # returns the list of 
        # sources that are required to build
        # the destination
        [ @get_source dest ]
    
    make_command: (src)->
        args = @command_args.slice()
        args.push src
        [ @command, args ]
    
    build: (dest, success, failure)->
        # Try to build the destination.
        # At this point we assume all sources
        # have already been built.
        src = @get_source dest
        console.log "compiling " + src + " -> " + dest
        cmd = @make_command src
        dest_file = fs.createWriteStream dest,W_FILE
        child = spawn.apply @,cmd
        child.stdout.pipe dest_file
        error_msg = ""
        child.stderr.on "data",(data)->
            error_msg += data.toString()
        child.on "exit",(code)->
            if (code==0)
                success()
            else
                console.log "compilation failed"
                fs.unlink dest
                failure error_msg

concatenate = (sources,dest_file,success,failure)->
    if sources.length == 0
        success()
    else
        try
            [h,t] = headtail sources
            f = fs.createReadStream h
            f.on "end",->
                concatenate t, dest_file, success, failure
            f.pipe dest_file,
        catch err
            failure "Bundle failure!"

class BundleCompiler extends Compiler
    ###
    Compiler with 1-1 relationship between
    source files and dest files 
    and an explicit extension for both.
    ###    
    
    match: (dest)->
        # Returns true if the destination
        # can actually be built by this compiler.
        source = @get_bundle_detail_file dest
        path.existsSync source
    
    get_bundle_detail_file: (dest)->
        dest+".bundle"

    get_source_list: (dest)->    
        # returns the list of 
        # sources that are required to build
        # the destination
        [ @get_bundle_detail_file(dest) ].concat @get_target_list(dest)
    
    get_target_list: (dest)->
        root = path.dirname dest
        bundle_detail_file = @get_bundle_detail_file dest
        bundle_detail_data = (fs.readFileSync bundle_detail_file,'utf-8').toString()
        splitPtn = new RegExp "\\s+"
        sources = []
        for l in bundle_detail_data.split splitPtn
            relpath = l.trim()
            if relpath.length > 0
                sources.push (path.join root,relpath)
        sources
        
    build: (dest, success, failure)->
        # Try to build the destination.
        # At this point we assume all sources
        # have already been built.
        targets = @get_target_list dest
        dest_file = fs.createWriteStream dest,W_FILE
        concatenate targets,dest_file,success,failure

writeScriptTags = (sources,dest_file,urlPrefix,success,failure) ->
    scriptTags = ""
    for source in sources
        scriptTags += "\\t<script src='#{urlPrefix + source}' text='javascript'></script>\\n"
    fs.writeSync dest_file, 'document.write("' + scriptTags + '");\n'
    fs.closeSync dest_file
    success()


class ReleaseBundleCompiler extends BundleCompiler
    
    constructor: ->
        @uglify = require 'uglify-js'
    
    build: (dest, success, failure)->
        targets = @get_target_list dest
        dest_file = fs.openSync dest,'w', W_FILE

        dest_file = fs.createWriteStream dest,W_FILE
        child = spawn 'uglifyjs' , [ "-b" , "--reserved-names", "arguments" ]
        concatenate targets,child.stdin,((m)->console.log "concat success"),((m)->console.log "error")
        child.stdout.pipe dest_file
        error_msg = ""
        child.stderr.on "data",(data)->
            console.log "ERR:",data.toString()
            error_msg += data.toString()
        child.on "exit",(code)->
            if (code==0)
                success()
            else
                console.log "compilation failed"
                fs.unlink dest
                failure error_msg



class DebugBundleCompiler extends BundleCompiler
    
    constructor: (config)->
        @urlPrefix = config.urlPrefix
                
    get_source_list: (dest)->
        # returns the list of 
        # sources that are required to build
        # the destination
        [ @get_bundle_detail_file(dest) ]
    
    build: (dest, success, failure)->
        # Try to build the destination.
        # At this point we assume all sources
        # have already been built.
        targets = @get_target_list dest
        dest_file = fs.openSync dest,'w', W_FILE
        writeScriptTags targets,dest_file,@urlPrefix,success,failure

class TrivialCompiler extends Compiler
    # Simply serve already existing 
    # files
    match: (dest)->
        true
    
    get_source_list: (dest)->
        []
    
    build: (dest, success, failure)->
        if path.existsSync dest
            success()
        else
            failure "File not found."

class Builder

    constructor: (@alwaysCompile)->
        @history = {}
        @compilers = []
    
    register_compiler: (compiler)->
        @compilers.push compiler

    buildAll: (dests, success, failure)->
        if dests.length == 0
            success()
        else
            [dest, remaining] = headtail dests
            @build dest, (=>@buildAll remaining,success,failure), failure
           
    
    _build_with_compiler: (compiler, dest, success, failure)->
        sources = compiler.get_source_list dest
        sources_are_ready = =>
            older_than_dest = (src)=>
                is_fresher dest,src
            if (@alwaysCompile) or (not @history[dest]?) or (not path.existsSync dest) or not all older_than_dest,sources
                @history[dest] = true
                compiler.build dest,success,failure
            else
                # no need to compile anyway.
                success()
        @buildAll sources.slice(),sources_are_ready,failure
    
    build: (dest, success, failure)->
        ###
        build destination when required
        ###
        for compiler in @compilers
            if compiler.match dest
                # we found the good compiler
                @_build_with_compiler compiler, dest, success, failure
                return
        failure
            msg: "couldn't find any compiler"


makeBuilderConcat = (config)->
    builder = new Builder (config.alwaysCompile==true)
    builder.register_compiler new BundleCompiler
    builder.register_compiler new SimpleCompiler 'coffee', 'js', 'coffee', ['-p']
    try
        sprite = require 'tumbler-sprite'
        builder.register_compiler new sprite.SpriteCompiler()
    catch exception
        console.log "Couldn't load sprite"
    builder.register_compiler new SimpleCompiler 'less', 'css', 'lessc',[]
    builder.register_compiler new TrivialCompiler()
    builder

makeBuilderRelease = (config)->
    builder = new Builder (config.alwaysCompile==true)
    builder.register_compiler new ReleaseBundleCompiler
    builder.register_compiler new SimpleCompiler 'coffee', 'js', 'coffee', ['-p']
    try
        sprite = require 'tumbler-sprite'
        builder.register_compiler new sprite.SpriteCompiler()
    catch exception
        console.log "Couldn't load sprite"
    builder.register_compiler new SimpleCompiler 'less', 'css', 'lessc',[]
    builder.register_compiler new TrivialCompiler()
    builder


makeBuilderDebug = (config)->
    builder = new Builder (config.alwaysCompile==true)
    builder.register_compiler new DebugBundleCompiler
        urlPrefix: "http://" + config.host + ":" + config.port + "/"
    builder.register_compiler new SimpleCompiler 'coffee', 'js', 'coffee', ['-p']
    try
        sprite = require 'tumbler-sprite'
        builder.register_compiler new sprite.SpriteCompiler()
    catch exception
        console.log "Couldn't load sprite"
    builder.register_compiler new SimpleCompiler 'less', 'css', 'lessc',[]
    builder.register_compiler new TrivialCompiler()
    builder

MODES =
    "release": makeBuilderRelease
    "concat": makeBuilderConcat
    "debug": makeBuilderDebug

makeBuilder = (config)->
    MODES[config.mode](config)
    
exports.makeBuilder = makeBuilder
exports.Compiler = Compiler
exports.BundleCompiler = BundleCompiler
exports.SimpleCompiler = SimpleCompiler
exports.TrivialCompiler = TrivialCompiler
exports.Builder = Builder
