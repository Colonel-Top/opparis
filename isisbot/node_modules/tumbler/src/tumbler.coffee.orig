#!/usr/bin/env coffee

fs = require 'fs' 
path = require 'path'
spawn = require('child_process').spawn

W_FILE =
    flags: 'w'
    encoding: 'utf-8'

extract_extension = (filepath)->
    ext_match = filepath.match /(.*)\.([^\.]+)/
    if ext_match 
        base: ext_match[1]
        ext: ext_match[2]
        filepath: filepath
    else
        base: filepath
        ext: null
        filepath: filepath

is_fresher = (src, dest)->
    ###
    src and dest must be existing
    filepaths.
    Returns true if src has been modified 
    more recently than dest.
    ###
    src_stat = fs.statSync src
    dest_stat = fs.statSync dest 
    src_stat.mtime > dest_stat.mtime

class Compiler 

    match: (dest)->
        # Returns true if the destination
        # can actually be built by this compiler.
    
    get_source_list: (dest)->
        # returns the list of 
        # sources that are required to build
        # the destination
    
    build: (dest, success, failure)->
        # here we may assume all sources
        # have already been built.


all = (predicate, els)->
    for el in els
        if not (predicate el)
            return false
    true


class SimpleCompiler extends Compiler
    ###
    Compiler with 1-1 relationship between
    source files and dest files 
    and an explicit extension for both.
    ###
    constructor: (@extSrc,@extDest,@command,@command_args=[])->
    
    match: (dest)->
        # Returns true if the destination
        # can actually be built by this compiler.
        split = extract_extension dest
        (split.ext==@extDest) and (path.existsSync @get_source dest)
    
    get_source: (dest)->
        split = extract_extension dest
        split.base + "." + @extSrc
    
    get_source_list: (dest)->
        # returns the list of 
        # sources that are required to build
        # the destination
        [ @get_source dest ]
    
    make_command: (src)->
        args = @command_args.slice()
        args.push src
        [ @command, args ]
    
    build: (dest, success, failure)->
        # Try to build the destination.
        # At this point we assume all sources
        # have already been built.
        src = @get_source dest
        console.log "compiling " + src + " -> " + dest
        cmd = @make_command src
        console.log "COMMAND" , cmd
        dest_file = fs.createWriteStream dest,W_FILE
        child = spawn.apply @,cmd
        child.stdout.pipe dest_file 
        error_msg = ""
        child.stderr.on "data",(data)->
            error_msg += data.toString()
        child.on "exit",(code)->
            if (code==0)
                success()
            else
                console.log "compilation failed"
                fs.unlink dest
                failure error_msg

concatenate = (sources,dest_file,success,failure)->
    if sources.length == 0
        success()
    else
        try
            head = sources[0]
            tail = sources[1..]
            f = fs.createReadStream head
            f.on "end",->
                concatenate tail, dest_file, success, failure
            f.pipe dest_file,
        catch err
            failure "Bundle failure!"



class UglifyCompiler extends SimpleCompiler
    ###
    Compiler with 1-1 relationship between
    source files and dest files 
    and an explicit extension for both.
    ###    
    constructor: ()->
        @command="uglifyjs"
        @command_args=[]
    
    match: (dest)->
        # Returns true if the destination
        # can actually be built by this compiler.
        dest[-7...] == "-min.js"
        
    get_source: (dest)->
        dest[...-7] + ".js"   
    
    get_source_list: (dest)->
        # returns the list of 
        # sources that are required to build
        # the destination
        [ @get_source dest ]




class BundleCompiler extends Compiler
    
    match: (dest)->
        # Returns true if the destination
        # can actually be built by this compiler.
        source = @get_bundle_detail_file dest
        path.existsSync source
    
    get_bundle_detail_file: (dest)->
        dest+".bundle"
    
    get_source_list: (dest)->
        # returns the list of 
        # sources that are required to build
        # the destination
        root = path.dirname dest
        bundle_detail_file = @get_bundle_detail_file dest
        bundle_detail_data = (fs.readFileSync bundle_detail_file,'utf-8').toString()
        splitPtn = new RegExp "\\s+"
        sources = []
        for l in bundle_detail_data.split splitPtn
            relpath = l.trim()
            if relpath.length > 0
                sources.push (path.join root,relpath)
        sources
    
    make_command: (src)->
        args = @command_args.slice()
        args.push src
        [ @command, args ]
    
    build: (dest, success, failure)->
        # Try to build the destination.
        # At this point we assume all sources
        # have already been built.
        sources = @get_source_list dest
        console.log dest, " via concatenating:"
        dest_file = fs.createWriteStream dest,W_FILE
        concatenate sources,dest_file,success,failure

  
class TrivialCompiler extends Compiler
    # Simply serve already existing 
    # files
    match: (dest)->
        true
    
    get_source_list: (dest)->
        []
    
    build: (dest, success, failure)->
        if path.existsSync dest
            success()
        else
            failure "File not found."

class Builder

    constructor: ->
        @compilers = []
    
    register_compiler: (compiler)->
        @compilers.push compiler

    buildAll: (dests, success, failure)->
        if dests.length == 0
            success()
        else
            dest = dests.pop()
            @build dest, (=>@buildAll dests,success,failure), failure
           
    
    _build_with_compiler: (compiler, dest, success, failure)->
        sources = compiler.get_source_list dest
        sources_are_ready = ->
            older_than_dest = (src)->is_fresher dest,src
            if (not path.existsSync dest) or all older_than_dest,sources
                compiler.build dest,success,failure
            else
                # no need to compile anyway.
                success()
        @buildAll sources,sources_are_ready,failure
    
    build: (dest, success, failure)->
        ###
        build destination when required
        ###
        for compiler in @compilers
            if compiler.match dest
                # we found the good compiler
                @_build_with_compiler compiler, dest, success, failure
                return
        failure
            msg: "couldn't find any compiler"


makeBuilder = (config)->
    builder = new Builder()
    builder.register_compiler new BundleCompiler()
    builder.register_compiler new SimpleCompiler 'coffee', 'js', 'coffee', ['-p']
    try
        sprite = require 'tumbler-sprite'
        builder.register_compiler new sprite.SpriteCompiler()
    catch exception
        console.log "Couldn't load sprite"
    builder.register_compiler new SimpleCompiler 'less', 'css', 'lessc',[]
    builder.register_compiler new TrivialCompiler()
    builder

exports.makeBuilder = makeBuilder
exports.Compiler = Compiler
exports.BundleCompiler = BundleCompiler
exports.SimpleCompiler = SimpleCompiler
exports.TrivialCompiler = TrivialCompiler
exports.UglifyCompiler = UglifyCompiler
exports.Builder = Builder